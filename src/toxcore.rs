/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TOX_VERSION_MAJOR: u32 = 0;
pub const TOX_VERSION_MINOR: u32 = 2;
pub const TOX_VERSION_PATCH: u32 = 2;
pub const TOX_PUBLIC_KEY_SIZE: u32 = 32;
pub const TOX_SECRET_KEY_SIZE: u32 = 32;
pub const TOX_MAX_NAME_LENGTH: u32 = 128;
pub const TOX_MAX_STATUS_MESSAGE_LENGTH: u32 = 1007;
pub const TOX_MAX_FRIEND_REQUEST_LENGTH: u32 = 1016;
pub const TOX_MAX_MESSAGE_LENGTH: u32 = 1372;
pub const TOX_MAX_CUSTOM_PACKET_SIZE: u32 = 1373;
pub const TOX_HASH_LENGTH: u32 = 32;
pub const TOX_FILE_ID_LENGTH: u32 = 32;
pub const TOX_MAX_FILENAME_LENGTH: u32 = 255;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__max_align_ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__max_align_ld as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tox {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tox_version_major() -> u32;
}
extern "C" {
    pub fn tox_version_minor() -> u32;
}
extern "C" {
    pub fn tox_version_patch() -> u32;
}
extern "C" {
    /// Return whether the compiled library version is compatible with the passed
    /// version numbers.
    pub fn tox_version_is_compatible(major: u32, minor: u32, patch: u32) -> bool;
}
extern "C" {
    pub fn tox_public_key_size() -> u32;
}
extern "C" {
    pub fn tox_secret_key_size() -> u32;
}
extern "C" {
    pub fn tox_nospam_size() -> u32;
}
extern "C" {
    pub fn tox_address_size() -> u32;
}
extern "C" {
    pub fn tox_max_name_length() -> u32;
}
extern "C" {
    pub fn tox_max_status_message_length() -> u32;
}
extern "C" {
    pub fn tox_max_friend_request_length() -> u32;
}
extern "C" {
    pub fn tox_max_message_length() -> u32;
}
extern "C" {
    pub fn tox_max_custom_packet_size() -> u32;
}
extern "C" {
    pub fn tox_hash_length() -> u32;
}
extern "C" {
    pub fn tox_file_id_length() -> u32;
}
extern "C" {
    pub fn tox_max_filename_length() -> u32;
}
/// User is online and available.
pub const TOX_USER_STATUS_TOX_USER_STATUS_NONE: TOX_USER_STATUS = 0;
/// User is away. Clients can set this e.g. after a user defined
/// inactivity time.
pub const TOX_USER_STATUS_TOX_USER_STATUS_AWAY: TOX_USER_STATUS = 1;
/// User is busy. Signals to other clients that this client does not
/// currently wish to communicate.
pub const TOX_USER_STATUS_TOX_USER_STATUS_BUSY: TOX_USER_STATUS = 2;
/// Represents the possible statuses a client can have.
pub type TOX_USER_STATUS = u32;
/// Normal text message. Similar to PRIVMSG on IRC.
pub const TOX_MESSAGE_TYPE_TOX_MESSAGE_TYPE_NORMAL: TOX_MESSAGE_TYPE = 0;
/// A message describing an user action. This is similar to /me (CTCP ACTION)
/// on IRC.
pub const TOX_MESSAGE_TYPE_TOX_MESSAGE_TYPE_ACTION: TOX_MESSAGE_TYPE = 1;
/// Represents message types for tox_friend_send_message and conference
/// messages.
pub type TOX_MESSAGE_TYPE = u32;
/// Don't use a proxy.
pub const TOX_PROXY_TYPE_TOX_PROXY_TYPE_NONE: TOX_PROXY_TYPE = 0;
/// HTTP proxy using CONNECT.
pub const TOX_PROXY_TYPE_TOX_PROXY_TYPE_HTTP: TOX_PROXY_TYPE = 1;
/// SOCKS proxy for simple socket pipes.
pub const TOX_PROXY_TYPE_TOX_PROXY_TYPE_SOCKS5: TOX_PROXY_TYPE = 2;
/// Type of proxy used to connect to TCP relays.
pub type TOX_PROXY_TYPE = u32;
/// No savedata.
pub const TOX_SAVEDATA_TYPE_TOX_SAVEDATA_TYPE_NONE: TOX_SAVEDATA_TYPE = 0;
/// Savedata is one that was obtained from tox_get_savedata.
pub const TOX_SAVEDATA_TYPE_TOX_SAVEDATA_TYPE_TOX_SAVE: TOX_SAVEDATA_TYPE = 1;
/// Savedata is a secret key of length TOX_SECRET_KEY_SIZE.
pub const TOX_SAVEDATA_TYPE_TOX_SAVEDATA_TYPE_SECRET_KEY: TOX_SAVEDATA_TYPE = 2;
/// Type of savedata to create the Tox instance from.
pub type TOX_SAVEDATA_TYPE = u32;
/// Very detailed traces including all network activity.
pub const TOX_LOG_LEVEL_TOX_LOG_LEVEL_TRACE: TOX_LOG_LEVEL = 0;
/// Debug messages such as which port we bind to.
pub const TOX_LOG_LEVEL_TOX_LOG_LEVEL_DEBUG: TOX_LOG_LEVEL = 1;
/// Informational log messages such as video call status changes.
pub const TOX_LOG_LEVEL_TOX_LOG_LEVEL_INFO: TOX_LOG_LEVEL = 2;
/// Warnings about internal inconsistency or logic errors.
pub const TOX_LOG_LEVEL_TOX_LOG_LEVEL_WARNING: TOX_LOG_LEVEL = 3;
/// Severe unexpected errors caused by external or internal inconsistency.
pub const TOX_LOG_LEVEL_TOX_LOG_LEVEL_ERROR: TOX_LOG_LEVEL = 4;
/// Severity level of log messages.
pub type TOX_LOG_LEVEL = u32;
/// This event is triggered when the toxcore library logs an internal message.
/// This is mostly useful for debugging. This callback can be called from any
/// function, not just tox_iterate. This means the user data lifetime must at
/// least extend between registering and unregistering it or tox_kill.
///
/// Other toxcore modules such as toxav may concurrently call this callback at
/// any time. Thus, user code must make sure it is equipped to handle concurrent
/// execution, e.g. by employing appropriate mutex locking.
///
/// @param level The severity of the log message.
/// @param file The source file from which the message originated.
/// @param line The source line from which the message originated.
/// @param func The function from which the message originated.
/// @param message The log message.
/// @param user_data The user data pointer passed to tox_new in options.
pub type tox_log_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        level: TOX_LOG_LEVEL,
        file: *const ::std::os::raw::c_char,
        line: u32,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
/// This struct contains all the startup options for Tox. You must tox_options_new to
/// allocate an object of this type.
///
/// WARNING: Although this struct happens to be visible in the API, it is
/// effectively private. Do not allocate this yourself or access members
/// directly, as it *will* break binary compatibility frequently.
///
/// @deprecated The memory layout of this struct (size, alignment, and field
/// order) is not part of the ABI. To remain compatible, prefer to use tox_options_new to
/// allocate the object and accessor functions to set the members. The struct
/// will become opaque (i.e. the definition will become private) in v0.3.0.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tox_Options {
    /// The type of socket to create.
    ///
    /// If this is set to false, an IPv4 socket is created, which subsequently
    /// only allows IPv4 communication.
    /// If it is set to true, an IPv6 socket is created, allowing both IPv4 and
    /// IPv6 communication.
    pub ipv6_enabled: bool,
    /// Enable the use of UDP communication when available.
    ///
    /// Setting this to false will force Tox to use TCP only. Communications will
    /// need to be relayed through a TCP relay node, potentially slowing them down.
    /// Disabling UDP support is necessary when using anonymous proxies or Tor.
    pub udp_enabled: bool,
    /// Enable local network peer discovery.
    ///
    /// Disabling this will cause Tox to not look for peers on the local network.
    pub local_discovery_enabled: bool,
    /// Pass communications through a proxy.
    pub proxy_type: TOX_PROXY_TYPE,
    /// The IP address or DNS name of the proxy to be used.
    ///
    /// If used, this must be non-NULL and be a valid DNS name. The name must not
    /// exceed 255 characters, and be in a NUL-terminated C string format
    /// (255 chars + 1 NUL byte).
    ///
    /// This member is ignored (it can be NULL) if proxy_type is TOX_PROXY_TYPE_NONE.
    ///
    /// The data pointed at by this member is owned by the user, so must
    /// outlive the options object.
    pub proxy_host: *const ::std::os::raw::c_char,
    /// The port to use to connect to the proxy server.
    ///
    /// Ports must be in the range (1, 65535). The value is ignored if
    /// proxy_type is TOX_PROXY_TYPE_NONE.
    pub proxy_port: u16,
    /// The start port of the inclusive port range to attempt to use.
    ///
    /// If both start_port and end_port are 0, the default port range will be
    /// used: [33445, 33545].
    ///
    /// If either start_port or end_port is 0 while the other is non-zero, the
    /// non-zero port will be the only port in the range.
    ///
    /// Having start_port > end_port will yield the same behavior as if start_port
    /// and end_port were swapped.
    pub start_port: u16,
    /// The end port of the inclusive port range to attempt to use.
    pub end_port: u16,
    /// The port to use for the TCP server (relay). If 0, the TCP server is
    /// disabled.
    ///
    /// Enabling it is not required for Tox to function properly.
    ///
    /// When enabled, your Tox instance can act as a TCP relay for other Tox
    /// instance. This leads to increased traffic, thus when writing a client
    /// it is recommended to enable TCP server only if the user has an option
    /// to disable it.
    pub tcp_port: u16,
    /// Enables or disables UDP hole-punching in toxcore. (Default: enabled).
    pub hole_punching_enabled: bool,
    /// The type of savedata to load from.
    pub savedata_type: TOX_SAVEDATA_TYPE,
    /// The savedata.
    ///
    /// The data pointed at by this member is owned by the user, so must
    /// outlive the options object.
    pub savedata_data: *const u8,
    /// The length of the savedata.
    pub savedata_length: usize,
    /// Logging callback for the new tox instance.
    pub log_callback: tox_log_cb,
    /// User data pointer passed to the logging callback.
    pub log_user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Tox_Options() {
    assert_eq!(
        ::std::mem::size_of::<Tox_Options>(),
        64usize,
        concat!("Size of: ", stringify!(Tox_Options))
    );
    assert_eq!(
        ::std::mem::align_of::<Tox_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(Tox_Options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).ipv6_enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(ipv6_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).udp_enabled as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(udp_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Tox_Options>())).local_discovery_enabled as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(local_discovery_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).proxy_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(proxy_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).proxy_host as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(proxy_host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).proxy_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(proxy_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).start_port as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(start_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).end_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(end_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).tcp_port as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(tcp_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Tox_Options>())).hole_punching_enabled as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(hole_punching_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).savedata_type as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(savedata_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).savedata_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(savedata_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).savedata_length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(savedata_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).log_callback as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(log_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Tox_Options>())).log_user_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Tox_Options),
            "::",
            stringify!(log_user_data)
        )
    );
}
extern "C" {
    pub fn tox_options_get_ipv6_enabled(options: *const Tox_Options) -> bool;
}
extern "C" {
    pub fn tox_options_set_ipv6_enabled(options: *mut Tox_Options, ipv6_enabled: bool);
}
extern "C" {
    pub fn tox_options_get_udp_enabled(options: *const Tox_Options) -> bool;
}
extern "C" {
    pub fn tox_options_set_udp_enabled(options: *mut Tox_Options, udp_enabled: bool);
}
extern "C" {
    pub fn tox_options_get_local_discovery_enabled(options: *const Tox_Options) -> bool;
}
extern "C" {
    pub fn tox_options_set_local_discovery_enabled(
        options: *mut Tox_Options,
        local_discovery_enabled: bool,
    );
}
extern "C" {
    pub fn tox_options_get_proxy_type(options: *const Tox_Options) -> TOX_PROXY_TYPE;
}
extern "C" {
    pub fn tox_options_set_proxy_type(options: *mut Tox_Options, type_: TOX_PROXY_TYPE);
}
extern "C" {
    pub fn tox_options_get_proxy_host(options: *const Tox_Options)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn tox_options_set_proxy_host(
        options: *mut Tox_Options,
        host: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn tox_options_get_proxy_port(options: *const Tox_Options) -> u16;
}
extern "C" {
    pub fn tox_options_set_proxy_port(options: *mut Tox_Options, port: u16);
}
extern "C" {
    pub fn tox_options_get_start_port(options: *const Tox_Options) -> u16;
}
extern "C" {
    pub fn tox_options_set_start_port(options: *mut Tox_Options, start_port: u16);
}
extern "C" {
    pub fn tox_options_get_end_port(options: *const Tox_Options) -> u16;
}
extern "C" {
    pub fn tox_options_set_end_port(options: *mut Tox_Options, end_port: u16);
}
extern "C" {
    pub fn tox_options_get_tcp_port(options: *const Tox_Options) -> u16;
}
extern "C" {
    pub fn tox_options_set_tcp_port(options: *mut Tox_Options, tcp_port: u16);
}
extern "C" {
    pub fn tox_options_get_hole_punching_enabled(options: *const Tox_Options) -> bool;
}
extern "C" {
    pub fn tox_options_set_hole_punching_enabled(
        options: *mut Tox_Options,
        hole_punching_enabled: bool,
    );
}
extern "C" {
    pub fn tox_options_get_savedata_type(options: *const Tox_Options) -> TOX_SAVEDATA_TYPE;
}
extern "C" {
    pub fn tox_options_set_savedata_type(options: *mut Tox_Options, type_: TOX_SAVEDATA_TYPE);
}
extern "C" {
    pub fn tox_options_get_savedata_data(options: *const Tox_Options) -> *const u8;
}
extern "C" {
    pub fn tox_options_set_savedata_data(options: *mut Tox_Options, data: *const u8, length: usize);
}
extern "C" {
    pub fn tox_options_get_savedata_length(options: *const Tox_Options) -> usize;
}
extern "C" {
    pub fn tox_options_set_savedata_length(options: *mut Tox_Options, length: usize);
}
extern "C" {
    pub fn tox_options_get_log_callback(options: *const Tox_Options) -> tox_log_cb;
}
extern "C" {
    pub fn tox_options_set_log_callback(options: *mut Tox_Options, callback: tox_log_cb);
}
extern "C" {
    pub fn tox_options_get_log_user_data(
        options: *const Tox_Options,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tox_options_set_log_user_data(
        options: *mut Tox_Options,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Initialises a Tox_Options object with the default options.
    ///
    /// The result of this function is independent of the original options. All
    /// values will be overwritten, no values will be read (so it is permissible
    /// to pass an uninitialised object).
    ///
    /// If options is NULL, this function has no effect.
    ///
    /// @param options An options object to be filled with default options.
    pub fn tox_options_default(options: *mut Tox_Options);
}
/// The function returned successfully.
pub const TOX_ERR_OPTIONS_NEW_TOX_ERR_OPTIONS_NEW_OK: TOX_ERR_OPTIONS_NEW = 0;
/// The function failed to allocate enough memory for the options struct.
pub const TOX_ERR_OPTIONS_NEW_TOX_ERR_OPTIONS_NEW_MALLOC: TOX_ERR_OPTIONS_NEW = 1;
pub type TOX_ERR_OPTIONS_NEW = u32;
extern "C" {
    /// Allocates a new Tox_Options object and initialises it with the default
    /// options. This function can be used to preserve long term ABI compatibility by
    /// giving the responsibility of allocation and deallocation to the Tox library.
    ///
    /// Objects returned from this function must be freed using the tox_options_free
    /// function.
    ///
    /// @return A new Tox_Options object with default options or NULL on failure.
    pub fn tox_options_new(error: *mut TOX_ERR_OPTIONS_NEW) -> *mut Tox_Options;
}
extern "C" {
    /// Releases all resources associated with an options objects.
    ///
    /// Passing a pointer that was not returned by tox_options_new results in
    /// undefined behaviour.
    pub fn tox_options_free(options: *mut Tox_Options);
}
/// The function returned successfully.
pub const TOX_ERR_NEW_TOX_ERR_NEW_OK: TOX_ERR_NEW = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_NEW_TOX_ERR_NEW_NULL: TOX_ERR_NEW = 1;
/// The function was unable to allocate enough memory to store the internal
/// structures for the Tox object.
pub const TOX_ERR_NEW_TOX_ERR_NEW_MALLOC: TOX_ERR_NEW = 2;
/// The function was unable to bind to a port. This may mean that all ports
/// have already been bound, e.g. by other Tox instances, or it may mean
/// a permission error. You may be able to gather more information from errno.
pub const TOX_ERR_NEW_TOX_ERR_NEW_PORT_ALLOC: TOX_ERR_NEW = 3;
/// proxy_type was invalid.
pub const TOX_ERR_NEW_TOX_ERR_NEW_PROXY_BAD_TYPE: TOX_ERR_NEW = 4;
/// proxy_type was valid but the proxy_host passed had an invalid format
/// or was NULL.
pub const TOX_ERR_NEW_TOX_ERR_NEW_PROXY_BAD_HOST: TOX_ERR_NEW = 5;
/// proxy_type was valid, but the proxy_port was invalid.
pub const TOX_ERR_NEW_TOX_ERR_NEW_PROXY_BAD_PORT: TOX_ERR_NEW = 6;
/// The proxy address passed could not be resolved.
pub const TOX_ERR_NEW_TOX_ERR_NEW_PROXY_NOT_FOUND: TOX_ERR_NEW = 7;
/// The byte array to be loaded contained an encrypted save.
pub const TOX_ERR_NEW_TOX_ERR_NEW_LOAD_ENCRYPTED: TOX_ERR_NEW = 8;
/// The data format was invalid. This can happen when loading data that was
/// saved by an older version of Tox, or when the data has been corrupted.
/// When loading from badly formatted data, some data may have been loaded,
/// and the rest is discarded. Passing an invalid length parameter also
/// causes this error.
pub const TOX_ERR_NEW_TOX_ERR_NEW_LOAD_BAD_FORMAT: TOX_ERR_NEW = 9;
/// :: Creation and destruction
///
pub type TOX_ERR_NEW = u32;
extern "C" {
    /// @brief Creates and initialises a new Tox instance with the options passed.
    ///
    /// This function will bring the instance into a valid state. Running the event
    /// loop with a new instance will operate correctly.
    ///
    /// If loading failed or succeeded only partially, the new or partially loaded
    /// instance is returned and an error code is set.
    ///
    /// @param options An options object as described above. If this parameter is
    ///   NULL, the default options are used.
    ///
    /// @see tox_iterate for the event loop.
    ///
    /// @return A new Tox instance pointer on success or NULL on failure.
    pub fn tox_new(options: *const Tox_Options, error: *mut TOX_ERR_NEW) -> *mut Tox;
}
extern "C" {
    /// Releases all resources associated with the Tox instance and disconnects from
    /// the network.
    ///
    /// After calling this function, the Tox pointer becomes invalid. No other
    /// functions can be called, and the pointer value can no longer be read.
    pub fn tox_kill(tox: *mut Tox);
}
extern "C" {
    /// Calculates the number of bytes required to store the tox instance with
    /// tox_get_savedata. This function cannot fail. The result is always greater than 0.
    ///
    /// @see threading for concurrency implications.
    pub fn tox_get_savedata_size(tox: *const Tox) -> usize;
}
extern "C" {
    /// Store all information associated with the tox instance to a byte array.
    ///
    /// @param savedata A memory region large enough to store the tox instance
    ///   data. Call tox_get_savedata_size to find the number of bytes required. If this parameter
    ///   is NULL, this function has no effect.
    pub fn tox_get_savedata(tox: *const Tox, savedata: *mut u8);
}
/// The function returned successfully.
pub const TOX_ERR_BOOTSTRAP_TOX_ERR_BOOTSTRAP_OK: TOX_ERR_BOOTSTRAP = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_BOOTSTRAP_TOX_ERR_BOOTSTRAP_NULL: TOX_ERR_BOOTSTRAP = 1;
/// The address could not be resolved to an IP address, or the IP address
/// passed was invalid.
pub const TOX_ERR_BOOTSTRAP_TOX_ERR_BOOTSTRAP_BAD_HOST: TOX_ERR_BOOTSTRAP = 2;
/// The port passed was invalid. The valid port range is (1, 65535).
pub const TOX_ERR_BOOTSTRAP_TOX_ERR_BOOTSTRAP_BAD_PORT: TOX_ERR_BOOTSTRAP = 3;
/// :: Connection lifecycle and event loop
///
pub type TOX_ERR_BOOTSTRAP = u32;
extern "C" {
    /// Sends a "get nodes" request to the given bootstrap node with IP, port, and
    /// public key to setup connections.
    ///
    /// This function will attempt to connect to the node using UDP. You must use
    /// this function even if Tox_Options.udp_enabled was set to false.
    ///
    /// @param address The hostname or IP address (IPv4 or IPv6) of the node.
    /// @param port The port on the host on which the bootstrap Tox instance is
    ///   listening.
    /// @param public_key The long term public key of the bootstrap node
    ///   (TOX_PUBLIC_KEY_SIZE bytes).
    /// @return true on success.
    pub fn tox_bootstrap(
        tox: *mut Tox,
        address: *const ::std::os::raw::c_char,
        port: u16,
        public_key: *const u8,
        error: *mut TOX_ERR_BOOTSTRAP,
    ) -> bool;
}
extern "C" {
    /// Adds additional host:port pair as TCP relay.
    ///
    /// This function can be used to initiate TCP connections to different ports on
    /// the same bootstrap node, or to add TCP relays without using them as
    /// bootstrap nodes.
    ///
    /// @param address The hostname or IP address (IPv4 or IPv6) of the TCP relay.
    /// @param port The port on the host on which the TCP relay is listening.
    /// @param public_key The long term public key of the TCP relay
    ///   (TOX_PUBLIC_KEY_SIZE bytes).
    /// @return true on success.
    pub fn tox_add_tcp_relay(
        tox: *mut Tox,
        address: *const ::std::os::raw::c_char,
        port: u16,
        public_key: *const u8,
        error: *mut TOX_ERR_BOOTSTRAP,
    ) -> bool;
}
/// There is no connection. This instance, or the friend the state change is
/// about, is now offline.
pub const TOX_CONNECTION_TOX_CONNECTION_NONE: TOX_CONNECTION = 0;
/// A TCP connection has been established. For the own instance, this means it
/// is connected through a TCP relay, only. For a friend, this means that the
/// connection to that particular friend goes through a TCP relay.
pub const TOX_CONNECTION_TOX_CONNECTION_TCP: TOX_CONNECTION = 1;
/// A UDP connection has been established. For the own instance, this means it
/// is able to send UDP packets to DHT nodes, but may still be connected to
/// a TCP relay. For a friend, this means that the connection to that
/// particular friend was built using direct UDP packets.
pub const TOX_CONNECTION_TOX_CONNECTION_UDP: TOX_CONNECTION = 2;
/// Protocols that can be used to connect to the network or friends.
pub type TOX_CONNECTION = u32;
extern "C" {
    /// Return whether we are connected to the DHT. The return value is equal to the
    /// last value received through the `self_connection_status` callback.
    ///
    /// @deprecated This getter is deprecated. Use the event and store the status
    /// in the client state.
    pub fn tox_self_get_connection_status(tox: *const Tox) -> TOX_CONNECTION;
}
/// @param connection_status Whether we are connected to the DHT.
pub type tox_self_connection_status_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        connection_status: TOX_CONNECTION,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `self_connection_status` event. Pass NULL to unset.
    ///
    /// This event is triggered whenever there is a change in the DHT connection
    /// state. When disconnected, a client may choose to call tox_bootstrap again, to
    /// reconnect to the DHT. Note that this state may frequently change for short
    /// amounts of time. Clients should therefore not immediately bootstrap on
    /// receiving a disconnect.
    ///
    /// TODO(iphydf): how long should a client wait before bootstrapping again?
    pub fn tox_callback_self_connection_status(
        tox: *mut Tox,
        callback: tox_self_connection_status_cb,
    );
}
extern "C" {
    /// Return the time in milliseconds before tox_iterate() should be called again
    /// for optimal performance.
    pub fn tox_iteration_interval(tox: *const Tox) -> u32;
}
extern "C" {
    /// The main loop that needs to be run in intervals of tox_iteration_interval()
    /// milliseconds.
    pub fn tox_iterate(tox: *mut Tox, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Writes the Tox friend address of the client to a byte array. The address is
    /// not in human-readable format. If a client wants to display the address,
    /// formatting is required.
    ///
    /// @param address A memory region of at least TOX_ADDRESS_SIZE bytes. If this
    ///   parameter is NULL, this function has no effect.
    /// @see TOX_ADDRESS_SIZE for the address format.
    pub fn tox_self_get_address(tox: *const Tox, address: *mut u8);
}
extern "C" {
    /// Set the 4-byte nospam part of the address. This value is expected in host
    /// byte order. I.e. 0x12345678 will form the bytes [12, 34, 56, 78] in the
    /// nospam part of the Tox friend address.
    ///
    /// @param nospam Any 32 bit unsigned integer.
    pub fn tox_self_set_nospam(tox: *mut Tox, nospam: u32);
}
extern "C" {
    /// Get the 4-byte nospam part of the address. This value is returned in host
    /// byte order.
    pub fn tox_self_get_nospam(tox: *const Tox) -> u32;
}
extern "C" {
    /// Copy the Tox Public Key (long term) from the Tox object.
    ///
    /// @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
    ///   this parameter is NULL, this function has no effect.
    pub fn tox_self_get_public_key(tox: *const Tox, public_key: *mut u8);
}
extern "C" {
    /// Copy the Tox Secret Key from the Tox object.
    ///
    /// @param secret_key A memory region of at least TOX_SECRET_KEY_SIZE bytes. If
    ///   this parameter is NULL, this function has no effect.
    pub fn tox_self_get_secret_key(tox: *const Tox, secret_key: *mut u8);
}
/// The function returned successfully.
pub const TOX_ERR_SET_INFO_TOX_ERR_SET_INFO_OK: TOX_ERR_SET_INFO = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_SET_INFO_TOX_ERR_SET_INFO_NULL: TOX_ERR_SET_INFO = 1;
/// Information length exceeded maximum permissible size.
pub const TOX_ERR_SET_INFO_TOX_ERR_SET_INFO_TOO_LONG: TOX_ERR_SET_INFO = 2;
/// Common error codes for all functions that set a piece of user-visible
/// client information.
pub type TOX_ERR_SET_INFO = u32;
extern "C" {
    /// Set the nickname for the Tox client.
    ///
    /// Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is 0, the name
    /// parameter is ignored (it can be NULL), and the nickname is set back to empty.
    ///
    /// @param name A byte array containing the new nickname.
    /// @param length The size of the name byte array.
    ///
    /// @return true on success.
    pub fn tox_self_set_name(
        tox: *mut Tox,
        name: *const u8,
        length: usize,
        error: *mut TOX_ERR_SET_INFO,
    ) -> bool;
}
extern "C" {
    /// Return the length of the current nickname as passed to tox_self_set_name.
    ///
    /// If no nickname was set before calling this function, the name is empty,
    /// and this function returns 0.
    ///
    /// @see threading for concurrency implications.
    pub fn tox_self_get_name_size(tox: *const Tox) -> usize;
}
extern "C" {
    /// Write the nickname set by tox_self_set_name to a byte array.
    ///
    /// If no nickname was set before calling this function, the name is empty,
    /// and this function has no effect.
    ///
    /// Call tox_self_get_name_size to find out how much memory to allocate for
    /// the result.
    ///
    /// @param name A valid memory location large enough to hold the nickname.
    ///   If this parameter is NULL, the function has no effect.
    pub fn tox_self_get_name(tox: *const Tox, name: *mut u8);
}
extern "C" {
    /// Set the client's status message.
    ///
    /// Status message length cannot exceed TOX_MAX_STATUS_MESSAGE_LENGTH. If
    /// length is 0, the status parameter is ignored (it can be NULL), and the
    /// user status is set back to empty.
    pub fn tox_self_set_status_message(
        tox: *mut Tox,
        status_message: *const u8,
        length: usize,
        error: *mut TOX_ERR_SET_INFO,
    ) -> bool;
}
extern "C" {
    /// Return the length of the current status message as passed to tox_self_set_status_message.
    ///
    /// If no status message was set before calling this function, the status
    /// is empty, and this function returns 0.
    ///
    /// @see threading for concurrency implications.
    pub fn tox_self_get_status_message_size(tox: *const Tox) -> usize;
}
extern "C" {
    /// Write the status message set by tox_self_set_status_message to a byte array.
    ///
    /// If no status message was set before calling this function, the status is
    /// empty, and this function has no effect.
    ///
    /// Call tox_self_get_status_message_size to find out how much memory to allocate for
    /// the result.
    ///
    /// @param status_message A valid memory location large enough to hold the
    ///   status message. If this parameter is NULL, the function has no effect.
    pub fn tox_self_get_status_message(tox: *const Tox, status_message: *mut u8);
}
extern "C" {
    /// Set the client's user status.
    ///
    /// @param status One of the user statuses listed in the enumeration above.
    pub fn tox_self_set_status(tox: *mut Tox, status: TOX_USER_STATUS);
}
extern "C" {
    /// Returns the client's user status.
    pub fn tox_self_get_status(tox: *const Tox) -> TOX_USER_STATUS;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_OK: TOX_ERR_FRIEND_ADD = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_NULL: TOX_ERR_FRIEND_ADD = 1;
/// The length of the friend request message exceeded
/// TOX_MAX_FRIEND_REQUEST_LENGTH.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_TOO_LONG: TOX_ERR_FRIEND_ADD = 2;
/// The friend request message was empty. This, and the TOO_LONG code will
/// never be returned from tox_friend_add_norequest.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_NO_MESSAGE: TOX_ERR_FRIEND_ADD = 3;
/// The friend address belongs to the sending client.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_OWN_KEY: TOX_ERR_FRIEND_ADD = 4;
/// A friend request has already been sent, or the address belongs to a friend
/// that is already on the friend list.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_ALREADY_SENT: TOX_ERR_FRIEND_ADD = 5;
/// The friend address checksum failed.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_BAD_CHECKSUM: TOX_ERR_FRIEND_ADD = 6;
/// The friend was already there, but the nospam value was different.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_SET_NEW_NOSPAM: TOX_ERR_FRIEND_ADD = 7;
/// A memory allocation failed when trying to increase the friend list size.
pub const TOX_ERR_FRIEND_ADD_TOX_ERR_FRIEND_ADD_MALLOC: TOX_ERR_FRIEND_ADD = 8;
/// :: Friend list management
///
pub type TOX_ERR_FRIEND_ADD = u32;
extern "C" {
    /// Add a friend to the friend list and send a friend request.
    ///
    /// A friend request message must be at least 1 byte long and at most
    /// TOX_MAX_FRIEND_REQUEST_LENGTH.
    ///
    /// Friend numbers are unique identifiers used in all functions that operate on
    /// friends. Once added, a friend number is stable for the lifetime of the Tox
    /// object. After saving the state and reloading it, the friend numbers may not
    /// be the same as before. Deleting a friend creates a gap in the friend number
    /// set, which is filled by the next adding of a friend. Any pattern in friend
    /// numbers should not be relied on.
    ///
    /// If more than INT32_MAX friends are added, this function causes undefined
    /// behaviour.
    ///
    /// @param address The address of the friend (returned by tox_self_get_address of
    ///   the friend you wish to add) it must be TOX_ADDRESS_SIZE bytes.
    /// @param message The message that will be sent along with the friend request.
    /// @param length The length of the data byte array.
    ///
    /// @return the friend number on success, UINT32_MAX on failure.
    pub fn tox_friend_add(
        tox: *mut Tox,
        address: *const u8,
        message: *const u8,
        length: usize,
        error: *mut TOX_ERR_FRIEND_ADD,
    ) -> u32;
}
extern "C" {
    /// Add a friend without sending a friend request.
    ///
    /// This function is used to add a friend in response to a friend request. If the
    /// client receives a friend request, it can be reasonably sure that the other
    /// client added this client as a friend, eliminating the need for a friend
    /// request.
    ///
    /// This function is also useful in a situation where both instances are
    /// controlled by the same entity, so that this entity can perform the mutual
    /// friend adding. In this case, there is no need for a friend request, either.
    ///
    /// @param public_key A byte array of length TOX_PUBLIC_KEY_SIZE containing the
    ///   Public Key (not the Address) of the friend to add.
    ///
    /// @return the friend number on success, UINT32_MAX on failure.
    /// @see tox_friend_add for a more detailed description of friend numbers.
    pub fn tox_friend_add_norequest(
        tox: *mut Tox,
        public_key: *const u8,
        error: *mut TOX_ERR_FRIEND_ADD,
    ) -> u32;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_DELETE_TOX_ERR_FRIEND_DELETE_OK: TOX_ERR_FRIEND_DELETE = 0;
/// There was no friend with the given friend number. No friends were deleted.
pub const TOX_ERR_FRIEND_DELETE_TOX_ERR_FRIEND_DELETE_FRIEND_NOT_FOUND: TOX_ERR_FRIEND_DELETE = 1;
pub type TOX_ERR_FRIEND_DELETE = u32;
extern "C" {
    /// Remove a friend from the friend list.
    ///
    /// This does not notify the friend of their deletion. After calling this
    /// function, this client will appear offline to the friend and no communication
    /// can occur between the two.
    ///
    /// @param friend_number Friend number for the friend to be deleted.
    ///
    /// @return true on success.
    pub fn tox_friend_delete(
        tox: *mut Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_DELETE,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_BY_PUBLIC_KEY_TOX_ERR_FRIEND_BY_PUBLIC_KEY_OK:
    TOX_ERR_FRIEND_BY_PUBLIC_KEY = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FRIEND_BY_PUBLIC_KEY_TOX_ERR_FRIEND_BY_PUBLIC_KEY_NULL:
    TOX_ERR_FRIEND_BY_PUBLIC_KEY = 1;
/// No friend with the given Public Key exists on the friend list.
pub const TOX_ERR_FRIEND_BY_PUBLIC_KEY_TOX_ERR_FRIEND_BY_PUBLIC_KEY_NOT_FOUND:
    TOX_ERR_FRIEND_BY_PUBLIC_KEY = 2;
/// :: Friend list queries
///
pub type TOX_ERR_FRIEND_BY_PUBLIC_KEY = u32;
extern "C" {
    /// Return the friend number associated with that Public Key.
    ///
    /// @return the friend number on success, UINT32_MAX on failure.
    /// @param public_key A byte array containing the Public Key.
    pub fn tox_friend_by_public_key(
        tox: *const Tox,
        public_key: *const u8,
        error: *mut TOX_ERR_FRIEND_BY_PUBLIC_KEY,
    ) -> u32;
}
extern "C" {
    /// Checks if a friend with the given friend number exists and returns true if
    /// it does.
    pub fn tox_friend_exists(tox: *const Tox, friend_number: u32) -> bool;
}
extern "C" {
    /// Return the number of friends on the friend list.
    ///
    /// This function can be used to determine how much memory to allocate for
    /// tox_self_get_friend_list.
    pub fn tox_self_get_friend_list_size(tox: *const Tox) -> usize;
}
extern "C" {
    /// Copy a list of valid friend numbers into an array.
    ///
    /// Call tox_self_get_friend_list_size to determine the number of elements to allocate.
    ///
    /// @param friend_list A memory region with enough space to hold the friend
    ///   list. If this parameter is NULL, this function has no effect.
    pub fn tox_self_get_friend_list(tox: *const Tox, friend_list: *mut u32);
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_GET_PUBLIC_KEY_TOX_ERR_FRIEND_GET_PUBLIC_KEY_OK:
    TOX_ERR_FRIEND_GET_PUBLIC_KEY = 0;
/// No friend with the given number exists on the friend list.
pub const TOX_ERR_FRIEND_GET_PUBLIC_KEY_TOX_ERR_FRIEND_GET_PUBLIC_KEY_FRIEND_NOT_FOUND:
    TOX_ERR_FRIEND_GET_PUBLIC_KEY = 1;
pub type TOX_ERR_FRIEND_GET_PUBLIC_KEY = u32;
extern "C" {
    /// Copies the Public Key associated with a given friend number to a byte array.
    ///
    /// @param friend_number The friend number you want the Public Key of.
    /// @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
    ///   this parameter is NULL, this function has no effect.
    ///
    /// @return true on success.
    pub fn tox_friend_get_public_key(
        tox: *const Tox,
        friend_number: u32,
        public_key: *mut u8,
        error: *mut TOX_ERR_FRIEND_GET_PUBLIC_KEY,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_GET_LAST_ONLINE_TOX_ERR_FRIEND_GET_LAST_ONLINE_OK:
    TOX_ERR_FRIEND_GET_LAST_ONLINE = 0;
/// No friend with the given number exists on the friend list.
pub const TOX_ERR_FRIEND_GET_LAST_ONLINE_TOX_ERR_FRIEND_GET_LAST_ONLINE_FRIEND_NOT_FOUND:
    TOX_ERR_FRIEND_GET_LAST_ONLINE = 1;
pub type TOX_ERR_FRIEND_GET_LAST_ONLINE = u32;
extern "C" {
    /// Return a unix-time timestamp of the last time the friend associated with a given
    /// friend number was seen online. This function will return UINT64_MAX on error.
    ///
    /// @param friend_number The friend number you want to query.
    pub fn tox_friend_get_last_online(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_GET_LAST_ONLINE,
    ) -> u64;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_QUERY_TOX_ERR_FRIEND_QUERY_OK: TOX_ERR_FRIEND_QUERY = 0;
/// The pointer parameter for storing the query result (name, message) was
/// NULL. Unlike the `_self_` variants of these functions, which have no effect
/// when a parameter is NULL, these functions return an error in that case.
pub const TOX_ERR_FRIEND_QUERY_TOX_ERR_FRIEND_QUERY_NULL: TOX_ERR_FRIEND_QUERY = 1;
/// The friend_number did not designate a valid friend.
pub const TOX_ERR_FRIEND_QUERY_TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND: TOX_ERR_FRIEND_QUERY = 2;
/// Common error codes for friend state query functions.
pub type TOX_ERR_FRIEND_QUERY = u32;
extern "C" {
    /// Return the length of the friend's name. If the friend number is invalid, the
    /// return value is unspecified.
    ///
    /// The return value is equal to the `length` argument received by the last
    /// `friend_name` callback.
    pub fn tox_friend_get_name_size(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> usize;
}
extern "C" {
    /// Write the name of the friend designated by the given friend number to a byte
    /// array.
    ///
    /// Call tox_friend_get_name_size to determine the allocation size for the `name`
    /// parameter.
    ///
    /// The data written to `name` is equal to the data received by the last
    /// `friend_name` callback.
    ///
    /// @param name A valid memory region large enough to store the friend's name.
    ///
    /// @return true on success.
    pub fn tox_friend_get_name(
        tox: *const Tox,
        friend_number: u32,
        name: *mut u8,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> bool;
}
/// @param friend_number The friend number of the friend whose name changed.
/// @param name A byte array containing the same data as
///   tox_friend_get_name would write to its `name` parameter.
/// @param length A value equal to the return value of
///   tox_friend_get_name_size.
pub type tox_friend_name_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        name: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_name` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend changes their name.
    pub fn tox_callback_friend_name(tox: *mut Tox, callback: tox_friend_name_cb);
}
extern "C" {
    /// Return the length of the friend's status message. If the friend number is
    /// invalid, the return value is SIZE_MAX.
    pub fn tox_friend_get_status_message_size(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> usize;
}
extern "C" {
    /// Write the status message of the friend designated by the given friend number to a byte
    /// array.
    ///
    /// Call tox_friend_get_status_message_size to determine the allocation size for the `status_name`
    /// parameter.
    ///
    /// The data written to `status_message` is equal to the data received by the last
    /// `friend_status_message` callback.
    ///
    /// @param status_message A valid memory region large enough to store the friend's status message.
    pub fn tox_friend_get_status_message(
        tox: *const Tox,
        friend_number: u32,
        status_message: *mut u8,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> bool;
}
/// @param friend_number The friend number of the friend whose status message
///   changed.
/// @param message A byte array containing the same data as
///   tox_friend_get_status_message would write to its `status_message` parameter.
/// @param length A value equal to the return value of
///   tox_friend_get_status_message_size.
pub type tox_friend_status_message_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        message: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_status_message` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend changes their status message.
    pub fn tox_callback_friend_status_message(
        tox: *mut Tox,
        callback: tox_friend_status_message_cb,
    );
}
extern "C" {
    /// Return the friend's user status (away/busy/...). If the friend number is
    /// invalid, the return value is unspecified.
    ///
    /// The status returned is equal to the last status received through the
    /// `friend_status` callback.
    ///
    /// @deprecated This getter is deprecated. Use the event and store the status
    ///   in the client state.
    pub fn tox_friend_get_status(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> TOX_USER_STATUS;
}
/// @param friend_number The friend number of the friend whose user status
///   changed.
/// @param status The new user status.
pub type tox_friend_status_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        status: TOX_USER_STATUS,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_status` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend changes their user status.
    pub fn tox_callback_friend_status(tox: *mut Tox, callback: tox_friend_status_cb);
}
extern "C" {
    /// Check whether a friend is currently connected to this client.
    ///
    /// The result of this function is equal to the last value received by the
    /// `friend_connection_status` callback.
    ///
    /// @param friend_number The friend number for which to query the connection
    ///   status.
    ///
    /// @return the friend's connection status as it was received through the
    ///   `friend_connection_status` event.
    ///
    /// @deprecated This getter is deprecated. Use the event and store the status
    ///   in the client state.
    pub fn tox_friend_get_connection_status(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> TOX_CONNECTION;
}
/// @param friend_number The friend number of the friend whose connection status
///   changed.
/// @param connection_status The result of calling
///   tox_friend_get_connection_status on the passed friend_number.
pub type tox_friend_connection_status_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        connection_status: TOX_CONNECTION,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_connection_status` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend goes offline after having been online,
    /// or when a friend goes online.
    ///
    /// This callback is not called when adding friends. It is assumed that when
    /// adding friends, their connection status is initially offline.
    pub fn tox_callback_friend_connection_status(
        tox: *mut Tox,
        callback: tox_friend_connection_status_cb,
    );
}
extern "C" {
    /// Check whether a friend is currently typing a message.
    ///
    /// @param friend_number The friend number for which to query the typing status.
    ///
    /// @return true if the friend is typing.
    /// @return false if the friend is not typing, or the friend number was
    ///   invalid. Inspect the error code to determine which case it is.
    ///
    /// @deprecated This getter is deprecated. Use the event and store the status
    ///   in the client state.
    pub fn tox_friend_get_typing(
        tox: *const Tox,
        friend_number: u32,
        error: *mut TOX_ERR_FRIEND_QUERY,
    ) -> bool;
}
/// @param friend_number The friend number of the friend who started or stopped
///   typing.
/// @param is_typing The result of calling tox_friend_get_typing on the passed
///   friend_number.
pub type tox_friend_typing_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        is_typing: bool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_typing` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend starts or stops typing.
    pub fn tox_callback_friend_typing(tox: *mut Tox, callback: tox_friend_typing_cb);
}
/// The function returned successfully.
pub const TOX_ERR_SET_TYPING_TOX_ERR_SET_TYPING_OK: TOX_ERR_SET_TYPING = 0;
/// The friend number did not designate a valid friend.
pub const TOX_ERR_SET_TYPING_TOX_ERR_SET_TYPING_FRIEND_NOT_FOUND: TOX_ERR_SET_TYPING = 1;
/// :: Sending private messages
///
pub type TOX_ERR_SET_TYPING = u32;
extern "C" {
    /// Set the client's typing status for a friend.
    ///
    /// The client is responsible for turning it on or off.
    ///
    /// @param friend_number The friend to which the client is typing a message.
    /// @param typing The typing status. True means the client is typing.
    ///
    /// @return true on success.
    pub fn tox_self_set_typing(
        tox: *mut Tox,
        friend_number: u32,
        typing: bool,
        error: *mut TOX_ERR_SET_TYPING,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_OK: TOX_ERR_FRIEND_SEND_MESSAGE =
    0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_NULL:
    TOX_ERR_FRIEND_SEND_MESSAGE = 1;
/// The friend number did not designate a valid friend.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_FOUND:
    TOX_ERR_FRIEND_SEND_MESSAGE = 2;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_CONNECTED:
    TOX_ERR_FRIEND_SEND_MESSAGE = 3;
/// An allocation error occurred while increasing the send queue size.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ:
    TOX_ERR_FRIEND_SEND_MESSAGE = 4;
/// Message length exceeded TOX_MAX_MESSAGE_LENGTH.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_TOO_LONG:
    TOX_ERR_FRIEND_SEND_MESSAGE = 5;
/// Attempted to send a zero-length message.
pub const TOX_ERR_FRIEND_SEND_MESSAGE_TOX_ERR_FRIEND_SEND_MESSAGE_EMPTY:
    TOX_ERR_FRIEND_SEND_MESSAGE = 6;
pub type TOX_ERR_FRIEND_SEND_MESSAGE = u32;
extern "C" {
    /// Send a text chat message to an online friend.
    ///
    /// This function creates a chat message packet and pushes it into the send
    /// queue.
    ///
    /// The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
    /// must be split by the client and sent as separate messages. Other clients can
    /// then reassemble the fragments. Messages may not be empty.
    ///
    /// The return value of this function is the message ID. If a read receipt is
    /// received, the triggered `friend_read_receipt` event will be passed this message ID.
    ///
    /// Message IDs are unique per friend. The first message ID is 0. Message IDs are
    /// incremented by 1 each time a message is sent. If UINT32_MAX messages were
    /// sent, the next message ID is 0.
    ///
    /// @param type Message type (normal, action, ...).
    /// @param friend_number The friend number of the friend to send the message to.
    /// @param message A non-NULL pointer to the first element of a byte array
    ///   containing the message text.
    /// @param length Length of the message to be sent.
    pub fn tox_friend_send_message(
        tox: *mut Tox,
        friend_number: u32,
        type_: TOX_MESSAGE_TYPE,
        message: *const u8,
        length: usize,
        error: *mut TOX_ERR_FRIEND_SEND_MESSAGE,
    ) -> u32;
}
/// @param friend_number The friend number of the friend who received the message.
/// @param message_id The message ID as returned from tox_friend_send_message
///   corresponding to the message sent.
pub type tox_friend_read_receipt_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        message_id: u32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_read_receipt` event. Pass NULL to unset.
    ///
    /// This event is triggered when the friend receives the message sent with
    /// tox_friend_send_message with the corresponding message ID.
    pub fn tox_callback_friend_read_receipt(tox: *mut Tox, callback: tox_friend_read_receipt_cb);
}
/// @param public_key The Public Key of the user who sent the friend request.
/// @param message The message they sent along with the request.
/// @param length The size of the message byte array.
pub type tox_friend_request_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        public_key: *const u8,
        message: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_request` event. Pass NULL to unset.
    ///
    /// This event is triggered when a friend request is received.
    pub fn tox_callback_friend_request(tox: *mut Tox, callback: tox_friend_request_cb);
}
/// @param friend_number The friend number of the friend who sent the message.
/// @param message The message data they sent.
/// @param length The size of the message byte array.
pub type tox_friend_message_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        type_: TOX_MESSAGE_TYPE,
        message: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_message` event. Pass NULL to unset.
    ///
    /// This event is triggered when a message from a friend is received.
    pub fn tox_callback_friend_message(tox: *mut Tox, callback: tox_friend_message_cb);
}
extern "C" {
    /// Generates a cryptographic hash of the given data.
    ///
    /// This function may be used by clients for any purpose, but is provided
    /// primarily for validating cached avatars. This use is highly recommended to
    /// avoid unnecessary avatar updates.
    ///
    /// If hash is NULL or data is NULL while length is not 0 the function returns false,
    /// otherwise it returns true.
    ///
    /// This function is a wrapper to internal message-digest functions.
    ///
    /// @param hash A valid memory location the hash data. It must be at least
    ///   TOX_HASH_LENGTH bytes in size.
    /// @param data Data to be hashed or NULL.
    /// @param length Size of the data array or 0.
    ///
    /// @return true if hash was not NULL.
    pub fn tox_hash(hash: *mut u8, data: *const u8, length: usize) -> bool;
}
/// Arbitrary file data. Clients can choose to handle it based on the file name
/// or magic or any other way they choose.
pub const TOX_FILE_KIND_TOX_FILE_KIND_DATA: TOX_FILE_KIND = 0;
/// Avatar file_id. This consists of tox_hash(image).
/// Avatar data. This consists of the image data.
///
/// Avatars can be sent at any time the client wishes. Generally, a client will
/// send the avatar to a friend when that friend comes online, and to all
/// friends when the avatar changed. A client can save some traffic by
/// remembering which friend received the updated avatar already and only send
/// it if the friend has an out of date avatar.
///
/// Clients who receive avatar send requests can reject it (by sending
/// TOX_FILE_CONTROL_CANCEL before any other controls), or accept it (by
/// sending TOX_FILE_CONTROL_RESUME). The file_id of length TOX_HASH_LENGTH bytes
/// (same length as TOX_FILE_ID_LENGTH) will contain the hash. A client can compare
/// this hash with a saved hash and send TOX_FILE_CONTROL_CANCEL to terminate the avatar
/// transfer if it matches.
///
/// When file_size is set to 0 in the transfer request it means that the client
/// has no avatar.
pub const TOX_FILE_KIND_TOX_FILE_KIND_AVATAR: TOX_FILE_KIND = 1;
pub type TOX_FILE_KIND = u32;
/// Sent by the receiving side to accept a file send request. Also sent after a
/// TOX_FILE_CONTROL_PAUSE command to continue sending or receiving.
pub const TOX_FILE_CONTROL_TOX_FILE_CONTROL_RESUME: TOX_FILE_CONTROL = 0;
/// Sent by clients to pause the file transfer. The initial state of a file
/// transfer is always paused on the receiving side and running on the sending
/// side. If both the sending and receiving side pause the transfer, then both
/// need to send TOX_FILE_CONTROL_RESUME for the transfer to resume.
pub const TOX_FILE_CONTROL_TOX_FILE_CONTROL_PAUSE: TOX_FILE_CONTROL = 1;
/// Sent by the receiving side to reject a file send request before any other
/// commands are sent. Also sent by either side to terminate a file transfer.
pub const TOX_FILE_CONTROL_TOX_FILE_CONTROL_CANCEL: TOX_FILE_CONTROL = 2;
pub type TOX_FILE_CONTROL = u32;
/// The function returned successfully.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_OK: TOX_ERR_FILE_CONTROL = 0;
/// The friend_number passed did not designate a valid friend.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_FRIEND_NOT_FOUND: TOX_ERR_FILE_CONTROL = 1;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_FRIEND_NOT_CONNECTED: TOX_ERR_FILE_CONTROL = 2;
/// No file transfer with the given file number was found for the given friend.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_NOT_FOUND: TOX_ERR_FILE_CONTROL = 3;
/// A RESUME control was sent, but the file transfer is running normally.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_NOT_PAUSED: TOX_ERR_FILE_CONTROL = 4;
/// A RESUME control was sent, but the file transfer was paused by the other
/// party. Only the party that paused the transfer can resume it.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_DENIED: TOX_ERR_FILE_CONTROL = 5;
/// A PAUSE control was sent, but the file transfer was already paused.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_ALREADY_PAUSED: TOX_ERR_FILE_CONTROL = 6;
/// Packet queue is full.
pub const TOX_ERR_FILE_CONTROL_TOX_ERR_FILE_CONTROL_SENDQ: TOX_ERR_FILE_CONTROL = 7;
pub type TOX_ERR_FILE_CONTROL = u32;
extern "C" {
    /// Sends a file control command to a friend for a given file transfer.
    ///
    /// @param friend_number The friend number of the friend the file is being
    ///   transferred to or received from.
    /// @param file_number The friend-specific identifier for the file transfer.
    /// @param control The control command to send.
    ///
    /// @return true on success.
    pub fn tox_file_control(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        control: TOX_FILE_CONTROL,
        error: *mut TOX_ERR_FILE_CONTROL,
    ) -> bool;
}
/// When receiving TOX_FILE_CONTROL_CANCEL, the client should release the
/// resources associated with the file number and consider the transfer failed.
///
/// @param friend_number The friend number of the friend who is sending the file.
/// @param file_number The friend-specific file number the data received is
///   associated with.
/// @param control The file control command received.
pub type tox_file_recv_control_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        control: TOX_FILE_CONTROL,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `file_recv_control` event. Pass NULL to unset.
    ///
    /// This event is triggered when a file control command is received from a
    /// friend.
    pub fn tox_callback_file_recv_control(tox: *mut Tox, callback: tox_file_recv_control_cb);
}
/// The function returned successfully.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_OK: TOX_ERR_FILE_SEEK = 0;
/// The friend_number passed did not designate a valid friend.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_FRIEND_NOT_FOUND: TOX_ERR_FILE_SEEK = 1;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_FRIEND_NOT_CONNECTED: TOX_ERR_FILE_SEEK = 2;
/// No file transfer with the given file number was found for the given friend.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_NOT_FOUND: TOX_ERR_FILE_SEEK = 3;
/// File was not in a state where it could be seeked.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_DENIED: TOX_ERR_FILE_SEEK = 4;
/// Seek position was invalid
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_INVALID_POSITION: TOX_ERR_FILE_SEEK = 5;
/// Packet queue is full.
pub const TOX_ERR_FILE_SEEK_TOX_ERR_FILE_SEEK_SENDQ: TOX_ERR_FILE_SEEK = 6;
pub type TOX_ERR_FILE_SEEK = u32;
extern "C" {
    /// Sends a file seek control command to a friend for a given file transfer.
    ///
    /// This function can only be called to resume a file transfer right before
    /// TOX_FILE_CONTROL_RESUME is sent.
    ///
    /// @param friend_number The friend number of the friend the file is being
    ///   received from.
    /// @param file_number The friend-specific identifier for the file transfer.
    /// @param position The position that the file should be seeked to.
    pub fn tox_file_seek(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        position: u64,
        error: *mut TOX_ERR_FILE_SEEK,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_FILE_GET_TOX_ERR_FILE_GET_OK: TOX_ERR_FILE_GET = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FILE_GET_TOX_ERR_FILE_GET_NULL: TOX_ERR_FILE_GET = 1;
/// The friend_number passed did not designate a valid friend.
pub const TOX_ERR_FILE_GET_TOX_ERR_FILE_GET_FRIEND_NOT_FOUND: TOX_ERR_FILE_GET = 2;
/// No file transfer with the given file number was found for the given friend.
pub const TOX_ERR_FILE_GET_TOX_ERR_FILE_GET_NOT_FOUND: TOX_ERR_FILE_GET = 3;
pub type TOX_ERR_FILE_GET = u32;
extern "C" {
    /// Copy the file id associated to the file transfer to a byte array.
    ///
    /// @param friend_number The friend number of the friend the file is being
    ///   transferred to or received from.
    /// @param file_number The friend-specific identifier for the file transfer.
    /// @param file_id A memory region of at least TOX_FILE_ID_LENGTH bytes. If
    ///   this parameter is NULL, this function has no effect.
    ///
    /// @return true on success.
    pub fn tox_file_get_file_id(
        tox: *const Tox,
        friend_number: u32,
        file_number: u32,
        file_id: *mut u8,
        error: *mut TOX_ERR_FILE_GET,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_OK: TOX_ERR_FILE_SEND = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_NULL: TOX_ERR_FILE_SEND = 1;
/// The friend_number passed did not designate a valid friend.
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_FRIEND_NOT_FOUND: TOX_ERR_FILE_SEND = 2;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_FRIEND_NOT_CONNECTED: TOX_ERR_FILE_SEND = 3;
/// Filename length exceeded TOX_MAX_FILENAME_LENGTH bytes.
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_NAME_TOO_LONG: TOX_ERR_FILE_SEND = 4;
/// Too many ongoing transfers. The maximum number of concurrent file transfers
/// is 256 per friend per direction (sending and receiving).
pub const TOX_ERR_FILE_SEND_TOX_ERR_FILE_SEND_TOO_MANY: TOX_ERR_FILE_SEND = 5;
/// :: File transmission: sending
///
pub type TOX_ERR_FILE_SEND = u32;
extern "C" {
    /// Send a file transmission request.
    ///
    /// Maximum filename length is TOX_MAX_FILENAME_LENGTH bytes. The filename
    /// should generally just be a file name, not a path with directory names.
    ///
    /// If a non-UINT64_MAX file size is provided, it can be used by both sides to
    /// determine the sending progress. File size can be set to UINT64_MAX for streaming
    /// data of unknown size.
    ///
    /// File transmission occurs in chunks, which are requested through the
    /// `file_chunk_request` event.
    ///
    /// When a friend goes offline, all file transfers associated with the friend are
    /// purged from core.
    ///
    /// If the file contents change during a transfer, the behaviour is unspecified
    /// in general. What will actually happen depends on the mode in which the file
    /// was modified and how the client determines the file size.
    ///
    /// - If the file size was increased
    ///   - and sending mode was streaming (file_size = UINT64_MAX), the behaviour
    ///     will be as expected.
    ///   - and sending mode was file (file_size != UINT64_MAX), the
    ///     file_chunk_request callback will receive length = 0 when Core thinks
    ///     the file transfer has finished. If the client remembers the file size as
    ///     it was when sending the request, it will terminate the transfer normally.
    ///     If the client re-reads the size, it will think the friend cancelled the
    ///     transfer.
    /// - If the file size was decreased
    ///   - and sending mode was streaming, the behaviour is as expected.
    ///   - and sending mode was file, the callback will return 0 at the new
    ///     (earlier) end-of-file, signalling to the friend that the transfer was
    ///     cancelled.
    /// - If the file contents were modified
    ///   - at a position before the current read, the two files (local and remote)
    ///     will differ after the transfer terminates.
    ///   - at a position after the current read, the file transfer will succeed as
    ///     expected.
    ///   - In either case, both sides will regard the transfer as complete and
    ///     successful.
    ///
    /// @param friend_number The friend number of the friend the file send request
    ///   should be sent to.
    /// @param kind The meaning of the file to be sent.
    /// @param file_size Size in bytes of the file the client wants to send, UINT64_MAX if
    ///   unknown or streaming.
    /// @param file_id A file identifier of length TOX_FILE_ID_LENGTH that can be used to
    ///   uniquely identify file transfers across core restarts. If NULL, a random one will
    ///   be generated by core. It can then be obtained by using tox_file_get_file_id().
    /// @param filename Name of the file. Does not need to be the actual name. This
    ///   name will be sent along with the file send request.
    /// @param filename_length Size in bytes of the filename.
    ///
    /// @return A file number used as an identifier in subsequent callbacks. This
    ///   number is per friend. File numbers are reused after a transfer terminates.
    ///   On failure, this function returns UINT32_MAX. Any pattern in file numbers
    ///   should not be relied on.
    pub fn tox_file_send(
        tox: *mut Tox,
        friend_number: u32,
        kind: u32,
        file_size: u64,
        file_id: *const u8,
        filename: *const u8,
        filename_length: usize,
        error: *mut TOX_ERR_FILE_SEND,
    ) -> u32;
}
/// The function returned successfully.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_OK: TOX_ERR_FILE_SEND_CHUNK = 0;
/// The length parameter was non-zero, but data was NULL.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_NULL: TOX_ERR_FILE_SEND_CHUNK = 1;
/// The friend_number passed did not designate a valid friend.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_FOUND:
    TOX_ERR_FILE_SEND_CHUNK = 2;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_CONNECTED:
    TOX_ERR_FILE_SEND_CHUNK = 3;
/// No file transfer with the given file number was found for the given friend.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_NOT_FOUND: TOX_ERR_FILE_SEND_CHUNK = 4;
/// File transfer was found but isn't in a transferring state: (paused, done,
/// broken, etc...) (happens only when not called from the request chunk callback).
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_NOT_TRANSFERRING:
    TOX_ERR_FILE_SEND_CHUNK = 5;
/// Attempted to send more or less data than requested. The requested data size is
/// adjusted according to maximum transmission unit and the expected end of
/// the file. Trying to send less or more than requested will return this error.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_INVALID_LENGTH: TOX_ERR_FILE_SEND_CHUNK =
    6;
/// Packet queue is full.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_SENDQ: TOX_ERR_FILE_SEND_CHUNK = 7;
/// Position parameter was wrong.
pub const TOX_ERR_FILE_SEND_CHUNK_TOX_ERR_FILE_SEND_CHUNK_WRONG_POSITION: TOX_ERR_FILE_SEND_CHUNK =
    8;
pub type TOX_ERR_FILE_SEND_CHUNK = u32;
extern "C" {
    /// Send a chunk of file data to a friend.
    ///
    /// This function is called in response to the `file_chunk_request` callback. The
    /// length parameter should be equal to the one received though the callback.
    /// If it is zero, the transfer is assumed complete. For files with known size,
    /// Core will know that the transfer is complete after the last byte has been
    /// received, so it is not necessary (though not harmful) to send a zero-length
    /// chunk to terminate. For streams, core will know that the transfer is finished
    /// if a chunk with length less than the length requested in the callback is sent.
    ///
    /// @param friend_number The friend number of the receiving friend for this file.
    /// @param file_number The file transfer identifier returned by tox_file_send.
    /// @param position The file or stream position from which to continue reading.
    /// @return true on success.
    pub fn tox_file_send_chunk(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        position: u64,
        data: *const u8,
        length: usize,
        error: *mut TOX_ERR_FILE_SEND_CHUNK,
    ) -> bool;
}
/// If the length parameter is 0, the file transfer is finished, and the client's
/// resources associated with the file number should be released. After a call
/// with zero length, the file number can be reused for future file transfers.
///
/// If the requested position is not equal to the client's idea of the current
/// file or stream position, it will need to seek. In case of read-once streams,
/// the client should keep the last read chunk so that a seek back can be
/// supported. A seek-back only ever needs to read from the last requested chunk.
/// This happens when a chunk was requested, but the send failed. A seek-back
/// request can occur an arbitrary number of times for any given chunk.
///
/// In response to receiving this callback, the client should call the function
/// `tox_file_send_chunk` with the requested chunk. If the number of bytes sent
/// through that function is zero, the file transfer is assumed complete. A
/// client must send the full length of data requested with this callback.
///
/// @param friend_number The friend number of the receiving friend for this file.
/// @param file_number The file transfer identifier returned by tox_file_send.
/// @param position The file or stream position from which to continue reading.
/// @param length The number of bytes requested for the current chunk.
pub type tox_file_chunk_request_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        position: u64,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `file_chunk_request` event. Pass NULL to unset.
    ///
    /// This event is triggered when Core is ready to send more file data.
    pub fn tox_callback_file_chunk_request(tox: *mut Tox, callback: tox_file_chunk_request_cb);
}
/// The client should acquire resources to be associated with the file transfer.
/// Incoming file transfers start in the PAUSED state. After this callback
/// returns, a transfer can be rejected by sending a TOX_FILE_CONTROL_CANCEL
/// control command before any other control commands. It can be accepted by
/// sending TOX_FILE_CONTROL_RESUME.
///
/// @param friend_number The friend number of the friend who is sending the file
///   transfer request.
/// @param file_number The friend-specific file number the data received is
///   associated with.
/// @param kind The meaning of the file to be sent.
/// @param file_size Size in bytes of the file the client wants to send,
///   UINT64_MAX if unknown or streaming.
/// @param filename Name of the file. Does not need to be the actual name. This
///   name will be sent along with the file send request.
/// @param filename_length Size in bytes of the filename.
pub type tox_file_recv_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        kind: u32,
        file_size: u64,
        filename: *const u8,
        filename_length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `file_recv` event. Pass NULL to unset.
    ///
    /// This event is triggered when a file transfer request is received.
    pub fn tox_callback_file_recv(tox: *mut Tox, callback: tox_file_recv_cb);
}
/// When length is 0, the transfer is finished and the client should release the
/// resources it acquired for the transfer. After a call with length = 0, the
/// file number can be reused for new file transfers.
///
/// If position is equal to file_size (received in the file_receive callback)
/// when the transfer finishes, the file was received completely. Otherwise, if
/// file_size was UINT64_MAX, streaming ended successfully when length is 0.
///
/// @param friend_number The friend number of the friend who is sending the file.
/// @param file_number The friend-specific file number the data received is
///   associated with.
/// @param position The file position of the first byte in data.
/// @param data A byte array containing the received chunk.
/// @param length The length of the received chunk.
pub type tox_file_recv_chunk_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        file_number: u32,
        position: u64,
        data: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `file_recv_chunk` event. Pass NULL to unset.
    ///
    /// This event is first triggered when a file transfer request is received, and
    /// subsequently when a chunk of file data for an accepted request was received.
    pub fn tox_callback_file_recv_chunk(tox: *mut Tox, callback: tox_file_recv_chunk_cb);
}
/// Text-only conferences that must be accepted with the tox_conference_join function.
pub const TOX_CONFERENCE_TYPE_TOX_CONFERENCE_TYPE_TEXT: TOX_CONFERENCE_TYPE = 0;
/// Video conference. The function to accept these is in toxav.
pub const TOX_CONFERENCE_TYPE_TOX_CONFERENCE_TYPE_AV: TOX_CONFERENCE_TYPE = 1;
/// Conference types for the conference_invite event.
pub type TOX_CONFERENCE_TYPE = u32;
/// The invitation will remain valid until the inviting friend goes offline
/// or exits the conference.
///
/// @param friend_number The friend who invited us.
/// @param type The conference type (text only or audio/video).
/// @param cookie A piece of data of variable length required to join the
///   conference.
/// @param length The length of the cookie.
pub type tox_conference_invite_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        type_: TOX_CONFERENCE_TYPE,
        cookie: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `conference_invite` event. Pass NULL to unset.
    ///
    /// This event is triggered when the client is invited to join a conference.
    pub fn tox_callback_conference_invite(tox: *mut Tox, callback: tox_conference_invite_cb);
}
/// @param conference_number The conference number of the conference the message is intended for.
/// @param peer_number The ID of the peer who sent the message.
/// @param type The type of message (normal, action, ...).
/// @param message The message data.
/// @param length The length of the message.
pub type tox_conference_message_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        conference_number: u32,
        peer_number: u32,
        type_: TOX_MESSAGE_TYPE,
        message: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `conference_message` event. Pass NULL to unset.
    ///
    /// This event is triggered when the client receives a conference message.
    pub fn tox_callback_conference_message(tox: *mut Tox, callback: tox_conference_message_cb);
}
/// @param conference_number The conference number of the conference the title change is intended for.
/// @param peer_number The ID of the peer who changed the title.
/// @param title The title data.
/// @param length The title length.
pub type tox_conference_title_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        conference_number: u32,
        peer_number: u32,
        title: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `conference_title` event. Pass NULL to unset.
    ///
    /// This event is triggered when a peer changes the conference title.
    ///
    /// If peer_number == UINT32_MAX, then author is unknown (e.g. initial joining the conference).
    pub fn tox_callback_conference_title(tox: *mut Tox, callback: tox_conference_title_cb);
}
/// @param conference_number The conference number of the conference the
///   peer is in.
/// @param peer_number The ID of the peer who changed their nickname.
/// @param name A byte array containing the new nickname.
/// @param length The size of the name byte array.
pub type tox_conference_peer_name_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        conference_number: u32,
        peer_number: u32,
        name: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `conference_peer_name` event. Pass NULL to unset.
    ///
    /// This event is triggered when a peer changes their name.
    pub fn tox_callback_conference_peer_name(tox: *mut Tox, callback: tox_conference_peer_name_cb);
}
/// @param conference_number The conference number of the conference the
///   peer is in.
pub type tox_conference_peer_list_changed_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        conference_number: u32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `conference_peer_list_changed` event. Pass NULL to unset.
    ///
    /// This event is triggered when a peer joins or leaves the conference.
    pub fn tox_callback_conference_peer_list_changed(
        tox: *mut Tox,
        callback: tox_conference_peer_list_changed_cb,
    );
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_NEW_TOX_ERR_CONFERENCE_NEW_OK: TOX_ERR_CONFERENCE_NEW = 0;
/// The conference instance failed to initialize.
pub const TOX_ERR_CONFERENCE_NEW_TOX_ERR_CONFERENCE_NEW_INIT: TOX_ERR_CONFERENCE_NEW = 1;
pub type TOX_ERR_CONFERENCE_NEW = u32;
extern "C" {
    /// Creates a new conference.
    ///
    /// This function creates a new text conference.
    ///
    /// @return conference number on success, or UINT32_MAX on failure.
    pub fn tox_conference_new(tox: *mut Tox, error: *mut TOX_ERR_CONFERENCE_NEW) -> u32;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_DELETE_TOX_ERR_CONFERENCE_DELETE_OK: TOX_ERR_CONFERENCE_DELETE = 0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_DELETE_TOX_ERR_CONFERENCE_DELETE_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_DELETE = 1;
pub type TOX_ERR_CONFERENCE_DELETE = u32;
extern "C" {
    /// This function deletes a conference.
    ///
    /// @param conference_number The conference number of the conference to be deleted.
    ///
    /// @return true on success.
    pub fn tox_conference_delete(
        tox: *mut Tox,
        conference_number: u32,
        error: *mut TOX_ERR_CONFERENCE_DELETE,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_PEER_QUERY_TOX_ERR_CONFERENCE_PEER_QUERY_OK:
    TOX_ERR_CONFERENCE_PEER_QUERY = 0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_PEER_QUERY_TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_PEER_QUERY = 1;
/// The peer number passed did not designate a valid peer.
pub const TOX_ERR_CONFERENCE_PEER_QUERY_TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND:
    TOX_ERR_CONFERENCE_PEER_QUERY = 2;
/// The client is not connected to the conference.
pub const TOX_ERR_CONFERENCE_PEER_QUERY_TOX_ERR_CONFERENCE_PEER_QUERY_NO_CONNECTION:
    TOX_ERR_CONFERENCE_PEER_QUERY = 3;
/// Error codes for peer info queries.
pub type TOX_ERR_CONFERENCE_PEER_QUERY = u32;
extern "C" {
    /// Return the number of peers in the conference. Return value is unspecified on failure.
    pub fn tox_conference_peer_count(
        tox: *const Tox,
        conference_number: u32,
        error: *mut TOX_ERR_CONFERENCE_PEER_QUERY,
    ) -> u32;
}
extern "C" {
    /// Return the length of the peer's name. Return value is unspecified on failure.
    pub fn tox_conference_peer_get_name_size(
        tox: *const Tox,
        conference_number: u32,
        peer_number: u32,
        error: *mut TOX_ERR_CONFERENCE_PEER_QUERY,
    ) -> usize;
}
extern "C" {
    /// Copy the name of peer_number who is in conference_number to name.
    /// name must be at least TOX_MAX_NAME_LENGTH long.
    ///
    /// @return true on success.
    pub fn tox_conference_peer_get_name(
        tox: *const Tox,
        conference_number: u32,
        peer_number: u32,
        name: *mut u8,
        error: *mut TOX_ERR_CONFERENCE_PEER_QUERY,
    ) -> bool;
}
extern "C" {
    /// Copy the public key of peer_number who is in conference_number to public_key.
    /// public_key must be TOX_PUBLIC_KEY_SIZE long.
    ///
    /// @return true on success.
    pub fn tox_conference_peer_get_public_key(
        tox: *const Tox,
        conference_number: u32,
        peer_number: u32,
        public_key: *mut u8,
        error: *mut TOX_ERR_CONFERENCE_PEER_QUERY,
    ) -> bool;
}
extern "C" {
    /// Return true if passed peer_number corresponds to our own.
    pub fn tox_conference_peer_number_is_ours(
        tox: *const Tox,
        conference_number: u32,
        peer_number: u32,
        error: *mut TOX_ERR_CONFERENCE_PEER_QUERY,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_INVITE_TOX_ERR_CONFERENCE_INVITE_OK: TOX_ERR_CONFERENCE_INVITE = 0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_INVITE_TOX_ERR_CONFERENCE_INVITE_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_INVITE = 1;
/// The invite packet failed to send.
pub const TOX_ERR_CONFERENCE_INVITE_TOX_ERR_CONFERENCE_INVITE_FAIL_SEND: TOX_ERR_CONFERENCE_INVITE =
    2;
pub type TOX_ERR_CONFERENCE_INVITE = u32;
extern "C" {
    /// Invites a friend to a conference.
    ///
    /// @param friend_number The friend number of the friend we want to invite.
    /// @param conference_number The conference number of the conference we want to invite the friend to.
    ///
    /// @return true on success.
    pub fn tox_conference_invite(
        tox: *mut Tox,
        friend_number: u32,
        conference_number: u32,
        error: *mut TOX_ERR_CONFERENCE_INVITE,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_OK: TOX_ERR_CONFERENCE_JOIN = 0;
/// The cookie passed has an invalid length.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_INVALID_LENGTH: TOX_ERR_CONFERENCE_JOIN =
    1;
/// The conference is not the expected type. This indicates an invalid cookie.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_WRONG_TYPE: TOX_ERR_CONFERENCE_JOIN = 2;
/// The friend number passed does not designate a valid friend.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_FRIEND_NOT_FOUND:
    TOX_ERR_CONFERENCE_JOIN = 3;
/// Client is already in this conference.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_DUPLICATE: TOX_ERR_CONFERENCE_JOIN = 4;
/// Conference instance failed to initialize.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_INIT_FAIL: TOX_ERR_CONFERENCE_JOIN = 5;
/// The join packet failed to send.
pub const TOX_ERR_CONFERENCE_JOIN_TOX_ERR_CONFERENCE_JOIN_FAIL_SEND: TOX_ERR_CONFERENCE_JOIN = 6;
pub type TOX_ERR_CONFERENCE_JOIN = u32;
extern "C" {
    /// Joins a conference that the client has been invited to.
    ///
    /// @param friend_number The friend number of the friend who sent the invite.
    /// @param cookie Received via the `conference_invite` event.
    /// @param length The size of cookie.
    ///
    /// @return conference number on success, UINT32_MAX on failure.
    pub fn tox_conference_join(
        tox: *mut Tox,
        friend_number: u32,
        cookie: *const u8,
        length: usize,
        error: *mut TOX_ERR_CONFERENCE_JOIN,
    ) -> u32;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_SEND_MESSAGE_TOX_ERR_CONFERENCE_SEND_MESSAGE_OK:
    TOX_ERR_CONFERENCE_SEND_MESSAGE = 0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_SEND_MESSAGE_TOX_ERR_CONFERENCE_SEND_MESSAGE_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_SEND_MESSAGE = 1;
/// The message is too long.
pub const TOX_ERR_CONFERENCE_SEND_MESSAGE_TOX_ERR_CONFERENCE_SEND_MESSAGE_TOO_LONG:
    TOX_ERR_CONFERENCE_SEND_MESSAGE = 2;
/// The client is not connected to the conference.
pub const TOX_ERR_CONFERENCE_SEND_MESSAGE_TOX_ERR_CONFERENCE_SEND_MESSAGE_NO_CONNECTION:
    TOX_ERR_CONFERENCE_SEND_MESSAGE = 3;
/// The message packet failed to send.
pub const TOX_ERR_CONFERENCE_SEND_MESSAGE_TOX_ERR_CONFERENCE_SEND_MESSAGE_FAIL_SEND:
    TOX_ERR_CONFERENCE_SEND_MESSAGE = 4;
pub type TOX_ERR_CONFERENCE_SEND_MESSAGE = u32;
extern "C" {
    /// Send a text chat message to the conference.
    ///
    /// This function creates a conference message packet and pushes it into the send
    /// queue.
    ///
    /// The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
    /// must be split by the client and sent as separate messages. Other clients can
    /// then reassemble the fragments.
    ///
    /// @param conference_number The conference number of the conference the message is intended for.
    /// @param type Message type (normal, action, ...).
    /// @param message A non-NULL pointer to the first element of a byte array
    ///   containing the message text.
    /// @param length Length of the message to be sent.
    ///
    /// @return true on success.
    pub fn tox_conference_send_message(
        tox: *mut Tox,
        conference_number: u32,
        type_: TOX_MESSAGE_TYPE,
        message: *const u8,
        length: usize,
        error: *mut TOX_ERR_CONFERENCE_SEND_MESSAGE,
    ) -> bool;
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_TITLE_TOX_ERR_CONFERENCE_TITLE_OK: TOX_ERR_CONFERENCE_TITLE = 0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_TITLE_TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_TITLE = 1;
/// The title is too long or empty.
pub const TOX_ERR_CONFERENCE_TITLE_TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH:
    TOX_ERR_CONFERENCE_TITLE = 2;
/// The title packet failed to send.
pub const TOX_ERR_CONFERENCE_TITLE_TOX_ERR_CONFERENCE_TITLE_FAIL_SEND: TOX_ERR_CONFERENCE_TITLE = 3;
pub type TOX_ERR_CONFERENCE_TITLE = u32;
extern "C" {
    /// Return the length of the conference title. Return value is unspecified on failure.
    ///
    /// The return value is equal to the `length` argument received by the last
    /// `conference_title` callback.
    pub fn tox_conference_get_title_size(
        tox: *const Tox,
        conference_number: u32,
        error: *mut TOX_ERR_CONFERENCE_TITLE,
    ) -> usize;
}
extern "C" {
    /// Write the title designated by the given conference number to a byte array.
    ///
    /// Call tox_conference_get_title_size to determine the allocation size for the `title` parameter.
    ///
    /// The data written to `title` is equal to the data received by the last
    /// `conference_title` callback.
    ///
    /// @param title A valid memory region large enough to store the title.
    ///   If this parameter is NULL, this function has no effect.
    ///
    /// @return true on success.
    pub fn tox_conference_get_title(
        tox: *const Tox,
        conference_number: u32,
        title: *mut u8,
        error: *mut TOX_ERR_CONFERENCE_TITLE,
    ) -> bool;
}
extern "C" {
    /// Set the conference title and broadcast it to the rest of the conference.
    ///
    /// Title length cannot be longer than TOX_MAX_NAME_LENGTH.
    ///
    /// @return true on success.
    pub fn tox_conference_set_title(
        tox: *mut Tox,
        conference_number: u32,
        title: *const u8,
        length: usize,
        error: *mut TOX_ERR_CONFERENCE_TITLE,
    ) -> bool;
}
extern "C" {
    /// Return the number of conferences in the Tox instance.
    /// This should be used to determine how much memory to allocate for `tox_conference_get_chatlist`.
    pub fn tox_conference_get_chatlist_size(tox: *const Tox) -> usize;
}
extern "C" {
    /// Copy a list of valid conference IDs into the array chatlist. Determine how much space
    /// to allocate for the array with the `tox_conference_get_chatlist_size` function.
    pub fn tox_conference_get_chatlist(tox: *const Tox, chatlist: *mut u32);
}
/// The function returned successfully.
pub const TOX_ERR_CONFERENCE_GET_TYPE_TOX_ERR_CONFERENCE_GET_TYPE_OK: TOX_ERR_CONFERENCE_GET_TYPE =
    0;
/// The conference number passed did not designate a valid conference.
pub const TOX_ERR_CONFERENCE_GET_TYPE_TOX_ERR_CONFERENCE_GET_TYPE_CONFERENCE_NOT_FOUND:
    TOX_ERR_CONFERENCE_GET_TYPE = 1;
/// Returns the type of conference (TOX_CONFERENCE_TYPE) that conference_number is. Return value is
/// unspecified on failure.
pub type TOX_ERR_CONFERENCE_GET_TYPE = u32;
extern "C" {
    pub fn tox_conference_get_type(
        tox: *const Tox,
        conference_number: u32,
        error: *mut TOX_ERR_CONFERENCE_GET_TYPE,
    ) -> TOX_CONFERENCE_TYPE;
}
/// The function returned successfully.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_OK:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 0;
/// One of the arguments to the function was NULL when it was not expected.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_NULL:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 1;
/// The friend number did not designate a valid friend.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_FOUND:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 2;
/// This client is currently not connected to the friend.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_CONNECTED:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 3;
/// The first byte of data was not in the specified range for the packet type.
/// This range is 200-254 for lossy, and 160-191 for lossless packets.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_INVALID:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 4;
/// Attempted to send an empty packet.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_EMPTY:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 5;
/// Packet data length exceeded TOX_MAX_CUSTOM_PACKET_SIZE.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_TOO_LONG:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 6;
/// Packet queue is full.
pub const TOX_ERR_FRIEND_CUSTOM_PACKET_TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ:
    TOX_ERR_FRIEND_CUSTOM_PACKET = 7;
/// :: Low-level custom packet sending and receiving
///
pub type TOX_ERR_FRIEND_CUSTOM_PACKET = u32;
extern "C" {
    /// Send a custom lossy packet to a friend.
    ///
    /// The first byte of data must be in the range 200-254. Maximum length of a
    /// custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
    ///
    /// Lossy packets behave like UDP packets, meaning they might never reach the
    /// other side or might arrive more than once (if someone is messing with the
    /// connection) or might arrive in the wrong order.
    ///
    /// Unless latency is an issue, it is recommended that you use lossless custom
    /// packets instead.
    ///
    /// @param friend_number The friend number of the friend this lossy packet
    ///   should be sent to.
    /// @param data A byte array containing the packet data.
    /// @param length The length of the packet data byte array.
    ///
    /// @return true on success.
    pub fn tox_friend_send_lossy_packet(
        tox: *mut Tox,
        friend_number: u32,
        data: *const u8,
        length: usize,
        error: *mut TOX_ERR_FRIEND_CUSTOM_PACKET,
    ) -> bool;
}
extern "C" {
    /// Send a custom lossless packet to a friend.
    ///
    /// The first byte of data must be in the range 160-191. Maximum length of a
    /// custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
    ///
    /// Lossless packet behaviour is comparable to TCP (reliability, arrive in order)
    /// but with packets instead of a stream.
    ///
    /// @param friend_number The friend number of the friend this lossless packet
    ///   should be sent to.
    /// @param data A byte array containing the packet data.
    /// @param length The length of the packet data byte array.
    ///
    /// @return true on success.
    pub fn tox_friend_send_lossless_packet(
        tox: *mut Tox,
        friend_number: u32,
        data: *const u8,
        length: usize,
        error: *mut TOX_ERR_FRIEND_CUSTOM_PACKET,
    ) -> bool;
}
/// @param friend_number The friend number of the friend who sent a lossy packet.
/// @param data A byte array containing the received packet data.
/// @param length The length of the packet data byte array.
pub type tox_friend_lossy_packet_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        data: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_lossy_packet` event. Pass NULL to unset.
    ///
    pub fn tox_callback_friend_lossy_packet(tox: *mut Tox, callback: tox_friend_lossy_packet_cb);
}
/// @param friend_number The friend number of the friend who sent the packet.
/// @param data A byte array containing the received packet data.
/// @param length The length of the packet data byte array.
pub type tox_friend_lossless_packet_cb = ::std::option::Option<
    unsafe extern "C" fn(
        tox: *mut Tox,
        friend_number: u32,
        data: *const u8,
        length: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set the callback for the `friend_lossless_packet` event. Pass NULL to unset.
    ///
    pub fn tox_callback_friend_lossless_packet(
        tox: *mut Tox,
        callback: tox_friend_lossless_packet_cb,
    );
}
extern "C" {
    /// Writes the temporary DHT public key of this instance to a byte array.
    ///
    /// This can be used in combination with an externally accessible IP address and
    /// the bound port (from tox_self_get_udp_port) to run a temporary bootstrap node.
    ///
    /// Be aware that every time a new instance is created, the DHT public key
    /// changes, meaning this cannot be used to run a permanent bootstrap node.
    ///
    /// @param dht_id A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If this
    ///   parameter is NULL, this function has no effect.
    pub fn tox_self_get_dht_id(tox: *const Tox, dht_id: *mut u8);
}
/// The function returned successfully.
pub const TOX_ERR_GET_PORT_TOX_ERR_GET_PORT_OK: TOX_ERR_GET_PORT = 0;
/// The instance was not bound to any port.
pub const TOX_ERR_GET_PORT_TOX_ERR_GET_PORT_NOT_BOUND: TOX_ERR_GET_PORT = 1;
pub type TOX_ERR_GET_PORT = u32;
extern "C" {
    /// Return the UDP port this Tox instance is bound to.
    pub fn tox_self_get_udp_port(tox: *const Tox, error: *mut TOX_ERR_GET_PORT) -> u16;
}
extern "C" {
    /// Return the TCP port this Tox instance is bound to. This is only relevant if
    /// the instance is acting as a TCP relay.
    pub fn tox_self_get_tcp_port(tox: *const Tox, error: *mut TOX_ERR_GET_PORT) -> u16;
}
